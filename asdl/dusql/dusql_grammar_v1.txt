# Assumptions:
# 1. sql is correct
# 2. only table name has alias
# 3. only one intersect/union/except

# val: value(int/float/string)/sql(dict)/int(for column)
# col_unit: (agg_id, col_id, isDistinct(bool))
# val_unit: (unit_op, col_unit1, col_unit2)
# table_unit: (table_type, tab_id/sql)
# cond_unit: (agg_op, cmp_op, val_unit, val1, val2)
# condition: [cond_unit1, 'and'/'or', cond_unit2, ...]
# sql {
#   'select': [(agg_id, val_unit), (agg_id, val_unit), ...]
#   'from': {'table_units': [table_unit1, table_unit2, ...], 'conds': condition}
#   'where': condition
#   'groupBy': [col_unit1, col_unit2, ...]
#   'orderBy': ('asc'/'desc', [(agg_id, val_unit), (agg_id, val_unit), ...])
#   'having': condition
#   'limit': None/integer
#   'intersect': None/sql
#   'except': None/sql
#   'union': None/sql
# }

# CLAUSE_KEYWORDS = ('select', 'from', 'where', 'group', 'order', 'limit', 'intersect', 'union', 'except')
# JOIN_KEYWORDS = ('join', 'on', 'as')
# CMP_OPS = ('not_in', 'between', '==', '>', '<', '>=', '<=', '!=', 'in', 'like')
# UNIT_OPS = ('none', '-', '+', "*", '/')
# AGG_OPS = ('none', 'max', 'min', 'count', 'sum', 'avg')
# TABLE_TYPE = ('sql', 'table_unit')
# COND_OPS = ('and', 'or')
# SQL_OPS = ('intersect', 'union', 'except')
# ORDER_OPS = ('desc', 'asc')

##########################################################################
# Some limitations
# 1. distinct flag is not considered
# 2. at most one INTERSECT/UNION/Except
# 3. does not handle the JOIN of two same tables in FROM clause
# 4. for groupby items, we use col_id, while col_unit for other clauses

tab_id, col_id, val_id

sql = Intersect(sql_unit left_sql_unit, sql_unit right_sql_unit)
        | Union(sql_unit left_sql_unit, sql_unit right_sql_unit)
        | Except(sql_unit left_sql_unit, sql_unit right_sql_unit)
        | Single(sql_unit sql_unit)

sql_unit = FromSelectWhereGroupByOrderBy(from from, select select, condition where, groupby groupby, orderby orderby)
        | FromSelectGroupByOrderBy(from from, select select, groupby groupby, orderby orderby)
        | FromSelectWhereOrderBy(from from, select select, condition where, orderby orderby)
        | FromSelectWhereGroupBy(from from, select select, condition where, groupby groupby)
        | FromSelectWhere(from from, select select, condition where)
        | FromSelectGroupBy(from from, select select, groupby groupby)
        | FromSelectOrderBy(from from, select select, orderby orderby)
        | FromSelect(from from, select select)

# enumerable productions:
# [field:low,high] means the least number of fields is low, while the most is high
# [field:,high]: low is default to 1
# [field:low,]: high is default to pre-defined threshold, e.g. 10

select = SelectColumn[col_unit col_unit:1,5](col_unit col_unit)

from = FromTableOne(tab_id tab_id)
        | FromTable[tab_id tab_id:2,3](tab_id tab_id, condition from)
        | FromSQL(sql left_from_sql, sql right_from_sql)

groupby = GroupByColumn(col_id col_id)
        | GroupByHavingColumn(col_id col_id, condition having)

orderby = OrderByColumn(col_unit col_unit, order order)
        | OrderByLimitColumn(col_unit col_unit, order order, val_id limit)

order = Asc | Desc

condition = AndCondition[condition condition:2,2](condition condition)
        | OrCondition[condition condition:2,2](condition condition)
        | CmpCondition(cmp_op cmp_op, col_unit col_unit, value value)

cmp_op = Equal | NotEqual | GreaterThan | GreaterEqual | LessThan | LessEqual | Like | In | NotIn

value = SQLValue(sql value_sql) | LiteralValue(val_id val_id) | ColumnValue(col_id col_id)

col_unit = UnaryColumnUnit(agg_op agg_op, col_id col_id)
        | BinaryColumnUnit(agg_op agg_op, unit_op unit_op, col_id left_col_id, col_id right_col_id)

agg_op = None | Max | Min | Count | Sum | Avg

unit_op = Minus | Plus | Times | Divide
